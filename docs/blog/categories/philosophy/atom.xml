<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: philosophy | Jake McCrary]]></title>
  <link href="https://jakemccrary.com/blog/categories/philosophy/atom.xml" rel="self"/>
  <link href="https://jakemccrary.com/"/>
  <updated>2020-05-04T20:31:49-05:00</updated>
  <id>https://jakemccrary.com/</id>
  <author>
    <name><![CDATA[Jake McCrary]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Fast feedback is important]]></title>
    <link href="https://jakemccrary.com/blog/2019/10/08/fast-feedback-is-important/"/>
    <updated>2019-10-08T18:10:02-05:00</updated>
    <id>https://jakemccrary.com/blog/2019/10/08/fast-feedback-is-important</id>
    <content type="html"><![CDATA[<p>I was asked last year what I would focus on if I were leading a technology group.
My response was that I would focus on developing software with a focus on having fast feedback cycles.</p>

<p>Fast feedback cycles enable so much.</p>

<p>If you are working in a language that has a compile step and your compilation takes 100 milliseconds, you are going to feel free to compile all the time.
You&rsquo;ll get that feedback you&rsquo;ve screwed something up super fast.
If you project takes 30 minutes to compile, you definitely will not be compiling all the time.
As a result, you&rsquo;ll write more code between compilation attempts.
More code written leads to more areas where there could be a problem.
Instead of getting feedback extremely close to when you first wrote a chunk of code, now you are getting it much later.
Getting the feedback much later puts a higher cognitive load on you as now you need to recall what you were attempting to do there and it has been minutes (or tens of minutes or an hour) since you&rsquo;ve written that code.</p>

<p>When you are developing a new feature or fixing a bug having a quick feedback cycle from writing code to seeing tests pass or fail allows you to develop code faster with confidence.
As soon as that time to get feedback from running tests passes some threshold, all of a sudden you are not going to run tests all the time.
As a result you start writing more code between running your tests.
Now you have more areas where a problem could be introduced.</p>

<p>Lets make a diagram of the various steps of code through a developement lifecycle.</p>

<p>|Local Development| -> |Build Server| -> |Deploy to production| -> |Learn from deployed code|</p>

<p>Local Development is a series of</p>

<p>1) Write Code
2) Compile
3) Run tests
4) Push code to shared repository</p>

<p>Each step can cycle back to Step 1 (even Step 1).</p>

<p>Why is focusing on fast feedback cycles important?</p>

<p>Fast feedback cycles let you iterate on ideas faster. This lets you evolve quicker.</p>

<p>Slowness in any step lets distraction get it. It also encourages larger batches.</p>

<p>Larger batches of changes brings more risk.</p>
]]></content>
  </entry>
  
</feed>
