<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: emacs | Jake McCrary]]></title>
  <link href="http://jakemcc.github.com/blog/categories/emacs/atom.xml" rel="self"/>
  <link href="http://jakemcc.github.com/"/>
  <updated>2012-04-13T22:16:09-05:00</updated>
  <id>http://jakemcc.github.com/</id>
  <author>
    <name><![CDATA[Jake McCrary]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Quickly starting a powerful Clojure REPL]]></title>
    <link href="http://jakemcc.github.com/blog/2010/12/07/quickily-starting-a-powerful-clojure-repl/"/>
    <updated>2010-12-07T00:00:00-06:00</updated>
    <id>http://jakemcc.github.com/blog/2010/12/07/quickily-starting-a-powerful-clojure-repl</id>
    <content type="html"><![CDATA[<p>I often find myself browsing the Internet and then suddenly I want to have a Clojure REPL at my fingertips. As I've become better with emacs and <a href="http://www.emacswiki.org/ParEdit">paredit</a> I've become dependent on the powerful editing this combo affords. The rest of this post details how I changed my five step process into a two step process. It does not explain basic emacs/slime setup but rather explains how I cut a few steps out of a suboptimal workflow for getting a powerful Clojure REPL up and running in emacs.</p>

<p>My previous workflow was the following:</p>

<ol>
<li>Open a terminal</li>
<li>Change to the root of Clojure project where I use <a href="https://github.com/technomancy/leiningen">Leiningen</a> and have swank-clojure as a dependency.</li>
<li>Run the command <code>lein swank</code></li>
<li>Start emacs</li>
<li>Run <code>M-x slime-connect</code></li>
</ol>


<p>This five step process was terrible. From me seeing something interesting to try to having a REPL open took too much time.</p>

<p>Today I changed my process so it on takes two steps. They are:</p>

<ol>
<li>Start emacs</li>
<li>Run <code>M-x clojure-swank</code></li>
</ol>


<p>This is a much better. I'll admit had a lot of room for improvement so it wasn't too hard to make it better. Below are the steps I took to cut three steps.</p>

<p>First, using Leiningen 1.4.0, I ran <code>lein install swank-clojure 1.3.0-SNAPSHOT</code>. This installed a script called swank-clojure into $HOME/.lein/bin. When run, this script starts a swank server waiting for connections on port 4005.</p>

<p>Next I wrote a function in <a href="http://en.wikipedia.org/wiki/Emacs_Lisp">elisp</a> that gives emacs the ability to call the newly installed swank-clojure script, wait for the swank server to start, and then connect to it. This function, <code>clojure-swank</code>, can be seen below. It creates a buffer named <code>*clojure-swank*</code>, runs the newly installed script, and captures the output in the freshly created buffer. When the "Connection opened" line appears <code>slime-connect</code> is called, connecting emacs to the freshly started swank server. After this we are at the REPL with all the advantages that emacs and paredit give us.</p>

<p>``` cl</p>

<pre><code>(defun clojure-swank ()
  "Launch swank-clojure from users homedir/.lein/bin"
  (interactive)
  (let ((buffer (get-buffer-create "*clojure-swank*")))
    (flet ((display-buffer (buffer-or-name &amp;optional not-this-window frame) nil))
          (bury-buffer buffer)
          (shell-command "~/.lein/bin/swank-clojure &amp;" buffer))
    (set-process-filter (get-buffer-process buffer)
                        (lambda (process output)
                           (with-current-buffer "*clojure-swank*" (insert output))
                           (when (string-match "Connection opened on local port +\\([0-9]+\\)" output)
                             (slime-connect "localhost" (match-string 1 output))
                             (set-process-filter process nil))))
    (message "Starting swank.. ")))
</code></pre>

<p>```</p>

<p>I've also written a <code>clojure-kill-swank</code> function for stopping the swank server.</p>

<p>``` cl</p>

<pre><code>(defun clojure-kill-swank ()
  "Kill swank process started by lein swank."
  (interactive)
  (let ((process (get-buffer-process "*clojure-swank*")))
    (when process
      (ignore-errors (slime-quit-lisp))
      (let ((timeout 10))
        (while (and (&gt; timeout 0)
                    (eql 'run (process-status process)))
          (sit-for 1)
          (decf timeout)))
      (ignore-errors (kill-buffer "*clojure-swank*")))))
</code></pre>

<p>```</p>

<p>Both of those functions need to be added to a location where they will get defined on emacs start-up. Once this is done the powerful REPL you are used to emacs providing can be at your finger tips in practically no time at all.</p>
]]></content>
  </entry>
  
</feed>
