<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: sql | Jake McCrary]]></title>
  <link href="http://jakemcc.github.com/blog/categories/sql/atom.xml" rel="self"/>
  <link href="http://jakemcc.github.com/"/>
  <updated>2012-04-13T22:16:09-05:00</updated>
  <id>http://jakemcc.github.com/</id>
  <author>
    <name><![CDATA[Jake McCrary]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Creating a SQL table with a composite primary key in Clojure]]></title>
    <link href="http://jakemcc.github.com/blog/2011/01/19/creating-sql-table-with-composite-key-in-clojure/"/>
    <updated>2011-01-19T00:00:00-06:00</updated>
    <id>http://jakemcc.github.com/blog/2011/01/19/creating-sql-table-with-composite-key-in-clojure</id>
    <content type="html"><![CDATA[<p>I was interacting with a SQL database using Clojure and needed to create a table so I turned to <code>create-table</code> from <a href="http://clojure.github.com/clojure-contrib/sql-api.html">clojure.contrib.sql</a>. Looking at the <a href="http://clojure.github.com/clojure-contrib/sql-api.html#clojure.contrib.sql/create-table">docs</a> for <code>create-table</code> it seemed pretty straight forward. To create a table with columns <em>date</em>, <em>id</em>, <em>symbol</em>, <em>price</em>, and <em>quantity</em> you would write the following.</p>

<p>``` clojure</p>

<pre><code>(create-table "orders"
              [:date     "date"]
              [:id       "integer"]
              [:symbol   "char(10)"]
              [:price    "integer"]
              [:quantity "integer"])
</code></pre>

<p>```</p>

<p>The above works. I also wanted to specify that columns <em>date</em> and <em>id</em> to form a composite primary key. I wasn't sure how to specify a composite primary key with <code>create-table</code> and ended up diving into its <a href="https://github.com/clojure/clojure-contrib/blob/b8d2743d3a89e13fc9deb2844ca2167b34aaa9b6/src/main/clojure/clojure/contrib/sql.clj#L103">code</a>.</p>

<p>``` clojure</p>

<pre><code>(defn create-table
  "Creates a table on the open database connection given a table name and
  specs. Each spec is either a column spec: a vector containing a column
  name and optionally a type and other constraints, or a table-level
  constraint: a vector containing words that express the constraint. All
  words used to describe the table may be supplied as strings or keywords."
  [name &amp; specs]
  (do-commands                                              
   (format "CREATE TABLE %s (%s)"                           
           (as-str name)
           (apply str                                       
             (map as-str                                    
              (apply concat                                 
               (interpose [", "]                            
                (map (partial interpose " ") specs))))))))  
</code></pre>

<p>```</p>

<p>Looking at <code>create-table</code> we can see it creates a SQL statement which is then executed by <code>do-commands</code>. In order to have a composite key we need <code>do-commands</code> to execute a SQL statement that looks similar to below.</p>

<p>``` sql</p>

<pre><code>CREATE TABLE track(
  date date,
  id integer,
  symbol char(10),
  price integer,
  quantity integer,
  PRIMARY KEY (date, id)
)
</code></pre>

<p>```</p>

<p>Let's break down <code>create-table</code> to figure out what we need to pass it to make <code>do-commands</code> run the above statement. The code for <code>create-table</code> is repeated below with comments pointing out what step lines up the code.</p>

<p>``` clojure</p>

<pre><code>(defn create-table
  [name &amp; specs]
  (do-commands                                              ; step 7
   (format "CREATE TABLE %s (%s)"                           ; step 6
           (as-str name)
           (apply str                                       ; step 5
             (map as-str                                    ; step 4
              (apply concat                                 ; step 3
               (interpose [", "]                            ; step 2
                (map (partial interpose " ") specs))))))))  ; step 1
</code></pre>

<p>```</p>

<ol>
<li>First <code>create-table</code> takes the sequences in <code>specs</code> and puts a space between each element in each sequence.</li>
<li>The result of step 1 then has a vector containing a comma and a space interposed between each element of it.</li>
<li><code>concat</code> combined with <code>apply</code> is used to combine each element of the result of step 2 into a single sequence.</li>
<li><code>as-str</code> (from <a href="http://clojure.github.com/clojure-contrib/string-api.html#clojure.contrib.string/as-str">c.c.string</a>) is mapped over the result of step 3 to make sure every element is a string.</li>
<li><code>str</code> is used to make one string out of the sequence of strings from step 4.</li>
<li><code>format</code> is used to substitute in <code>name</code> and the result of step 5 to create the SQL statement.</li>
<li><code>do-commands</code> executes the statement created in step 6.</li>
</ol>


<p>Knowing how <code>create-table</code> works now allows us to specify the arguments that will create the orders table with the composite primary key of <em>date</em> and <em>id</em>.</p>

<p>``` clojure</p>

<pre><code>(create-table "orders"
              [:date     "date"]
              [:id       "integer"]
              [:symbol   "char(10)"]
              [:price    "integer"]
              [:quantity "integer"]
              ["PRIMARY KEY" "(date, id)")
</code></pre>

<p>```</p>
]]></content>
  </entry>
  
</feed>
