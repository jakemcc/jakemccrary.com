<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: linux | Jake McCrary]]></title>
  <link href="https://jakemccrary.com/blog/categories/linux/atom.xml" rel="self"/>
  <link href="https://jakemccrary.com/"/>
  <updated>2020-03-23T17:55:25-05:00</updated>
  <id>https://jakemccrary.com/</id>
  <author>
    <name><![CDATA[Jake McCrary]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Auto-syncing a git repository]]></title>
    <link href="https://jakemccrary.com/blog/2020/02/25/auto-syncing-a-git-repository/"/>
    <updated>2020-02-25T21:09:00-06:00</updated>
    <id>https://jakemccrary.com/blog/2020/02/25/auto-syncing-a-git-repository</id>
    <content type="html"><![CDATA[<p>I&rsquo;m currently keep notes on my computer using plain text and <a href="https://orgmode.org/">Org mode</a>.</p>

<p>I keep my notes in a git repository in my home directory, <code>~/org/</code>.
I want my notes to be synced between my computers without me thinking about it.
Historically, I&rsquo;ve reached for something like Google Drive or Dropbox to do this but this time I reached for git and GitHub.</p>

<p>Below is the script that I ended up cobbling together from various sources found online.
The script pushes and pulls changes from a remote repository and works on my macOS and linux machines.</p>

<p>The loop starting on line 38 does the work.
Whenever a file-watcher notices a change or 10 minutes passes, the loop pulls changes from a remote repository, commits any local changes, and pushes to the remote repository.
The lines before this are mostly checking that needed programs exist on the host.</p>

<p>I keep this running in a background terminal and I check periodically to confirm it is still running.
I could do something fancier but this isn&rsquo;t a critical system and the overhead of checking every couple days is nearly zero.
Most of the time checking happens by accident when I accidentally maximize the terminal that runs the script.</p>

<p>I&rsquo;ve been using this script for a long time now and I&rsquo;ve found it quite useful. I hope you do too.</p>

<pre><code class="bash">#!/bin/bash

set -e

TARGETDIR="$HOME/org/"

stderr () {
    echo "$1" &gt;&amp;2
}

is_command() {
    command -v "$1" &amp;&gt;/dev/null
}

if [ "$(uname)" != "Darwin" ]; then
    INW="inotifywait";
    EVENTS="close_write,move,delete,create";
    INCOMMAND="\"$INW\" -qr -e \"$EVENTS\" --exclude \"\.git\" \"$TARGETDIR\""
else # if Mac, use fswatch
    INW="fswatch";
    # default events specified via a mask, see
    # https://emcrisostomo.github.io/fswatch/doc/1.14.0/fswatch.html/Invoking-fswatch.html#Numeric-Event-Flags
    # default of 414 = MovedTo + MovedFrom + Renamed + Removed + Updated + Created
    #                = 256 + 128+ 16 + 8 + 4 + 2
    EVENTS="--event=414"
    INCOMMAND="\"$INW\" --recursive \"$EVENTS\" --exclude \"\.git\" --one-event \"$TARGETDIR\""
fi

for cmd in "git" "$INW" "timeout"; do
    # in OSX: `timeout` =&gt; brew install coreutils
    # in OSX: `fswatch` =&gt; brew install fswatch
    is_command "$cmd" || { stderr "Error: Required command '$cmd' not found"; exit 1; }
done

cd "$TARGETDIR"
echo "$INCOMMAND"

while true; do
    eval "timeout 600 $INCOMMAND" || true
    git pull
    sleep 5
    STATUS=$(git status -s)
    if [ -n "$STATUS" ]; then
        echo "$STATUS"
        echo "commit!"
        git add .
        git commit -m "autocommit"
        git push origin
    fi
done
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Using comm to verify file content matches]]></title>
    <link href="https://jakemccrary.com/blog/2017/05/29/using-comm-to-verify-matching-content/"/>
    <updated>2017-05-29T10:45:00-05:00</updated>
    <id>https://jakemccrary.com/blog/2017/05/29/using-comm-to-verify-matching-content</id>
    <content type="html"><![CDATA[<p>I recently found myself in a situation where I needed to confirm that a process took in a tab separated file, did some processing, and then output a new file containing the original columns with some additional ones. The feature I was adding allowed the process to die and restart while processing the input file and pick up where it left off.</p>

<p>I needed to confirm the output had data for every line in the input. I reached to the command line tool <code>comm</code>.</p>

<p>Below is a made up input file.</p>

<pre><code>UNIQUE_ID   USER
1   38101838
2   19183819
3   19123811
4   10348018
5   19881911
6   29182918
</code></pre>

<p>And here is some made up output.</p>

<pre><code>UNIQUE_ID   USER    MESSAGE
1   38101838    A01
2   19183819    A05
3   19123811    A02
4   10348018    A01
5   19881911    A02
6   29182918    A05
</code></pre>

<p>With files this size, it would be easy enough to check visually. In my testing, I was dealing with files that had thousands of lines. This is too many to check by hand. It is a perfect amount for <code>comm</code>.</p>

<p><a href="https://en.wikipedia.org/wiki/Comm">comm</a> reads two files as input and then outputs three columns. The first column contains lines found only in the first file, the second column contains lines only found in the second, and the last column contains lines in both. If it is easier for you to think about it as set operations, the first two columns are similar to performing two set differences and the third is similar to set intersection. Below is an example adapted from Wikipedia showing its behavior.</p>

<pre><code>$ cat foo.txt
apple
banana
eggplant
$ cat bar.txt
apple
banana
banana
zucchini
$ comm foo.txt bar.txt
                  apple
                  banana
          banana
eggplant
          zucchini
</code></pre>

<p>So how is this useful? Well, you can also tell <code>comm</code> to suppress outputting specific columns.  If we send the common columns from the input and output file to <code>comm</code> and suppress <code>comm</code>&rsquo;s third column then anything printed to the screen is a problem. Anything printed to the screen was found in one of the files and not the other. We&rsquo;ll select the common columns using cut and, since comm expects input to be sorted, then sort using <code>sort</code>. Let&rsquo;s see what happens.</p>

<pre><code>$ comm -3 &lt;(cut -f 1,2 input.txt | sort) &lt;(cut -f 1,2 output.txt | sort)
$
</code></pre>

<p>Success! Nothing was printed to the console, so there is nothing unique in either file.</p>

<p><code>comm</code> is a useful tool to have in your command line toolbox.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Manage your workspace with grids under Linux, OS X, and Windows]]></title>
    <link href="https://jakemccrary.com/blog/2013/04/15/manage-your-workspace-with-grids-under-linux-osx-and-windows/"/>
    <updated>2013-04-15T19:15:00-05:00</updated>
    <id>https://jakemccrary.com/blog/2013/04/15/manage-your-workspace-with-grids-under-linux-osx-and-windows</id>
    <content type="html"><![CDATA[<p>I&rsquo;m the type of computer user that wants an organized
workspace. To me this means having my active applications organized
into a grid. Efficiently doing this is important to me. Before I jump
into what tools I use let me give a quick explanation of what
organized into a grid means to me.</p>

<p>Imagine that your screen is divided both vertically and
horizontally. To me a good tool for managing windows lets you take
your active application and move it so it fits in any rectangle formed
by the edges of your screen and those two lines splitting your
monitor. This means that with a keystroke you can make the active
window take up the full screen, half screen, or quarter screen. Below
I&rsquo;ve listed the tools that let me do that.</p>

<h4>Linux</h4>

<p>I&rsquo;ve switched to using <a href="http://i3wm.org/">i3</a>, a
<a href="http://en.wikipedia.org/wiki/Tiling_window_manager">tiling window manager</a>
instead of the default window manager on every distribution I use. When using
i3 the tiling is done automatically. There are hotkeys for changing
window layout and for moving focus between windows. The automatic tiling and
shortcuts take a bit to get used to, but now that I am I can&rsquo;t believe
I switched to using a tiling window manager sometime in the last eight
months.</p>

<h4>Windows</h4>

<p>When developing under Windows I use
<a href="http://winsplit-revolution.com/">Winsplit Revolution</a>. Unlike i3,
Winsplit Revolution only provides hotkeys snapping windows to
different locations. This is admittedly more approachable than i3 as
the grid isn&rsquo;t forced on you. WinSplit Revolution is pretty flexible,
you can change shortcuts and even define your own grid.</p>

<p>I can&rsquo;t remember when I started using Winsplit Revolution but it has
become a vital tool for when I&rsquo;m stuck doing development on a Windows
machine.</p>

<h4>OS X</h4>

<p>My only OS X machine is my 13 inch MacBook Air. I always thought that
with such a small screen being able to tile my windows wouldn&rsquo;t be as
useful. I  was completely wrong. If anything it may be more useful
because of the tiny screen real estate. The 13 inch screen is just wide
enough to have an editor up on one half and documentation on the
other.</p>

<p>The tool I use to snap my windows to a grid is
<a href="http://spectacleapp.com/">Spectacle</a>. Spectacle provides some
sensible keystrokes for moving windows around. The hotkeys are
similar to Winsplit Revolution&rsquo;s which makes switching between
operating systems easy.</p>

<p>If you haven&rsquo;t tried using a tool to help you organize your windows I
highly recommend that you do. I&rsquo;ve introduced both technical and
non-technical people to these tools and everyone has enjoyed them.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Change volume from the command line]]></title>
    <link href="https://jakemccrary.com/blog/2013/03/31/change-volume-from-the-command-line/"/>
    <updated>2013-03-31T16:17:00-05:00</updated>
    <id>https://jakemccrary.com/blog/2013/03/31/change-volume-from-the-command-line</id>
    <content type="html"><![CDATA[<p>On my Ubuntu desktop the volume at 100% is often too quiet. With Ubuntu&rsquo;s default window manager I could open up the graphical &ldquo;Sound Preferences&rdquo; and bump the volume to above 100%. After using <a href="http://i3wm.org/">i3 window manager</a> for a while I found myself missing this and took the time to figure out how to do it from the command line.</p>

<p>Ubuntu uses <a href="http://www.freedesktop.org/wiki/Software/PulseAudio">PulseAudio</a> to handle sound related tasks. The tool <a href="http://linux.die.net/man/1/pacmd">pacmd</a> allows you to change PulseAudio settings, such as volume, on the fly. The command is <code>pacmd set-sink-volume &lt;sink-index&gt; &lt;sink-volume&gt;</code> where <code>&lt;sink-index&gt;</code> is an identifier for your output device and <code>&lt;sink-volume&gt;</code> is an integer greater than or equal to zero. Zero represents muted and 65536 represents 100% volume. <code>&lt;sink-index&gt;</code> is the index found in the output from the <code>pacmd list-sinks</code> for your output card. In my case it is 0.</p>

<p>The below script makes changing volume with <code>pacmd</code> straightforward. I&rsquo;m using Perl convert a percentage into the proper units for the <sink-volume> argument. Using this script if you want to pull a <a href="http://www.youtube.com/watch?v=EbVKWCpNFhY">Spinal Tap</a> and go above 100% you simply pass in a number greater than 100.</p>

<pre><code class="bash">    #!/bin/bash

    if [ "$1" == "" ]; then
      echo "Need to supply a percentage"
      exit 1
    fi

    vol=$(perl -e "print int(65536 * ($1 / 100))")
    echo "Setting volume to $1 ($vol)"
    pacmd set-sink-volume 0 $vol
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Maintaining Directory Layout When Selectively Copying Files]]></title>
    <link href="https://jakemccrary.com/blog/2013/02/03/maintaining-directory-layout-when-selectively-copying-files/"/>
    <updated>2013-02-03T12:24:00-06:00</updated>
    <id>https://jakemccrary.com/blog/2013/02/03/maintaining-directory-layout-when-selectively-copying-files</id>
    <content type="html"><![CDATA[<p>Ran into a situation where I needed to replace certain files in a directory tree with files from a similarly shaped directory tree. The other files in each tree needed to remain untouched. Below is an example of the directory structure.</p>

<pre><code class="bash">    root-dir
    ├── target-dir
    │   ├── 20121230
    │   │   ├── data.csv
    │   │   └── instruments.csv
    │   └── 20121231
    │       ├── data.csv
    │       └── instruments.csv
    └── other-dir
        ├── 20121230
        │   ├── data.csv
        │   └── instruments.csv
        └── 20121231
            ├── data.csv
            └── instruments.csv
</code></pre>

<p>Goal is to copy <strong>instruments.csv</strong> from the sub-directories of <strong>other-dir</strong> to the matching sub-directories of <strong>target-dir</strong>. In the past I&rsquo;ve solved this by being in the <strong>other-dir</strong> directory and banging out a <code>for</code> loop at the command line (<code>other-dir$</code> is the bash prompt).</p>

<pre><code class="bash">    other-dir$ for d in $(ls); do cp $d/instruments.txt ../target-dir/$d/; done
</code></pre>

<p>One feature (or issue) with this approach is that if a sub-directory exists in <strong>other-dir</strong> but not in <strong>target-dir</strong> that sub-directory will not be created in <strong>target-dir</strong>.</p>

<p>I took a bit of time to explore other ways of accomplishing this task and stopped after coming up with two additional ways.</p>

<pre><code class="bash">    other-dir$ find . -name "instruments.txt" | xargs -I {} cp {} ../target-dir/{} 
</code></pre>

<p>The above is basically the same as the first solution. It uses <code>find</code> to generate the list of files and then constructs <code>cp</code> commands. It also doesn&rsquo;t create sub-directories in <strong>target-dir</strong>.</p>

<p>The next example has different behavior from the above <code>cp</code> solutions. Like the second solution, it generates a list of files to copy using <code>find</code> but then uses <code>rsync</code> with the <code>--files-from</code> flag to mirror those files under <strong>target-dir</strong>. Unlike the <code>cp</code> based solutions, sub-directories of <strong>other-dir</strong> that do not exist in <strong>target-dir</strong> will be created.</p>

<pre><code>    other-dir$ find . -name "instruments.txt" | rsync --files-from=- . ../target-dir
</code></pre>

<p>I&rsquo;m sure there are many more ways of accomplishing this task. Figuring out the three above was enough for me. They are fairly straight forward and don&rsquo;t depend on esoteric command line flags. The solution I use in the future will depend on whether or not I need sub-directories created in the target directory.</p>
]]></content>
  </entry>
  
</feed>
